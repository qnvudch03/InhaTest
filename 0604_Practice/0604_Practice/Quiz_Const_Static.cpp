#include <iostream>

struct Player
{

};

int main()
{
	/*************************************
	* 1번)
	* 이 코드가 컴파일 될까요? 안된다면 이유도 함께
	/**************************************/
	{
		const int maxHp = 100;
		maxHp = 200;

	}

	// A) const int로 선언되었기에, maxhp를 통해서 int 값을 바꿀 수 없어 컴파일이 되지 않는다.

	/*************************************
	* 2번)
	* 함수를 이렇게 작성한 의도는 뭘까요?
	/**************************************/
	{
		void ShowInfo(const Player & player);
	}


	// A) 함수 이름이 Show인걸 보니, 보여주는것이 목적인 함수이다. 출력이 목적이기에 값의 수정을 사전에 방지하고자 위와 같이 선언했다고 볼 수 있다.


	/*************************************
	* 3번)
	* 각 1, 2, 3, 4에 대해 에러가 발생할까요 ?
	/**************************************/
	{
		int a = 10, b = 20;

		const int* p1 = &a;
		*p1 = 15;    // 1번 가능할까요?
		p1 = &b;     // 2번 가능할까요?

		int* const p2 = &a;
		*p2 = 30;    // 3번 가능할까요?
		p2 = &b;     // 4번 가능할까요?
	}


	// A) 'const int' 이기 때문에, p1 포인터를 통해서는 int의 값을 변경 할 수 없다.  1번은 불가능하고, 2번은 가능하다.
	//    'const 메모리주소' 이기 때문에, p2 포인터를 통해서는 메모리주소 값을 변경할 수 없다. 3번은 메모리가 가르키는 값을 바꾼것이니 가능하고, 4번은 p2의 메모리주소값을 변경하려고 했기에 안된다.


	/*************************************
	* 4번)
	* 이 코드가 컴파일 될까요? 안된다면 이유도 함께
	/**************************************/
	{
		int a = 10;
		const int& ref = a;

		ref = 20;
	}

	// A)  컴파일이 되지 않는다, 'const int' 이기 때문에, ref를 통해서는 int의 값을 변경 할 수 없다.


	/*************************************
	* 5번)
	* 포인터 자체를 상수로 만드려면 ? 즉, p가 가리키는 주소값 변경이 불가능하게 하려면
	/**************************************/
	{
		_____ int* _____ p;


	}


	// A) int* const p   이다.  이러면 'const 메모리주소' 이기 때문에, p 를 통해서는 메모리주소 값을 바꿀 수 없게 된다.


	/*************************************
	* 6번)
	* (*p)로 값을 바꿀 수 (있다) / (없다)
	/**************************************/
	{
		const int* p = &a;
	}

	// A) 'const int' 이기 떄문에, p를 통해서 int 값을 바꾸는 것이 불가능 하다. 바꿀 수 없다.


	/*************************************
	* 7번)
	* 아래 코드의 출력 결과는 어떻게 나올까요?
	/**************************************/
	{
		int a = 5;
		const int* p = &a;
		a = 10;
		std::cout << *p << std::endl;
	}

	// A) 10


	/*************************************
	* 8번)
	* 아래 코드의 출력 결과는 어떻게 나올까요?
	/**************************************/
	{
		void Func()
		{
			int id = 1;
			cout << id << endl;

			id++;
		}

		int main()
		{
			Func();
			Func();
		}
	}

	// A) 1
	//	  1	  


	/*************************************
	* 9번)
	* 아래 코드의 출력 결과는 어떻게 나올까요? 그 이유에 대해서 아는대로 적어주세요.
	/**************************************/
	{
		void Func()
		{
			static int id = 1;
			cout << id << endl;

			id++;
		}

		int main()
		{
			Func();
			Func();
		}
	}


	// A) 1
	//    2
	// 
	// static으로 선언된 변수는 딱 한번만 초기화가 되고, 전역변수처럼 데이터 영역에 저장이되어 Func의 함수의 호출이 종료되어도 살아있다.
	// 맨처음 Func의 함수호출로 id 라는 변수가 1이라는 데이터로 초기화가 된다. 
	// 1 출력후 ++ 연산자에 의해 2라는 값으로 데이터 영역에 저장이 된다. id에 저장된 값은 Func함수를 탈출해도 살아있었고 다음 Func때 초기화를 건너뛰어 저장되어있던 2를 출력 후 3이란 값으로 저장이 된다.
	// 
}